package com.grocottlab.atlas_toolkit;

/**
 * Atlas Toolkit plugin for ImageJ and Fiji.
 * Copyright (C) 2015 Timothy Grocott 
 *
 * More information at http://www.grocottlab.com/software
 *
 * This file is part of Atlas Toolkit.
 * 
 * Atlas Toolkit is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (http://www.gnu.org/licenses/gpl.txt )
 *
 * Atlas Toolkit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
import ij.io.OpenDialog;
import ij.plugin.PlugIn;
import ij.plugin.frame.PlugInFrame;
import ij.process.ByteProcessor;
import ij3d.Content;
import ij3d.Image3DUniverse;
import ij3d.ImageCanvas3D;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.*;
import java.util.Random;
import java.util.Stack;
import javax.media.j3d.Background;
import javax.media.j3d.Canvas3D;
import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.tree.TreeModel;
import javax.vecmath.Color3f;
import org.netbeans.swing.outline.DefaultOutlineModel;
import org.netbeans.swing.outline.Outline;
import org.netbeans.swing.outline.OutlineModel;
import org.netbeans.swing.outline.RowModel;

/**
 * A class for 3D reconstruction of hierarchical clustering results generated by the Cluster 3.0 software.
 * 
 * This class is called by the Atlas Toolkit menu command "7. Cluster Viewer".
 * 
 */
public class Tree2Volume_ implements PlugIn {

	String[][] arry_mapping;
	int[] bins = new int[3];
	ClusterTreeModel clusterTree;
        //String results_file;
	String cluster_filepath;
	String tree_filepath;
        String intersection_filepath;
        ImagePlus intersection;
	private Image3DUniverse univ;
	boolean animating = false;
        private Outline outline;
        private Tree2VolumeUI UI;
        private Color backgroundColor = new Color(235, 235, 235);//Color.WHITE;
        private JPanel panel3d;
        private Dendrogram treeView;
        private int geneCount;
        private String[] geneName;
        private float[][] map;
        private HeatMap heatmap;

	public void run(String arg) {

		// Get cdt file name & path
		OpenDialog od = new OpenDialog("Select a Clustered Data Table file (*.cdt)...", "");
		if (od.getFileName() == null) return;
		cluster_filepath = od.getDirectory() + od.getFileName();
                
		// Get tree file name & path
		od = new OpenDialog("Select a tree file (*.atr)...", "");
		if (od.getFileName() == null) return;
		tree_filepath = od.getDirectory() + od.getFileName();
                
                // Get intersection label
                od = new OpenDialog("Select an intersection file (*.tif)...", "");
		if (od.getFileName() == null) return;
		intersection_filepath = od.getDirectory() + od.getFileName();
                intersection = new ImagePlus(intersection_filepath);

		// Parse bin size
		parseBinSize(cluster_filepath);
                
                // Parse geneCount
                parseGenes(cluster_filepath);

		// Construct the ClusterTreeModel from the given .atr file
		clusterTree = new ClusterTreeModel(tree_filepath);
                
                // Start-up the user interface
		UI = new Tree2VolumeUI();
	}

	// This class constructs the user interface
	private class Tree2VolumeUI extends PlugInFrame {

		public Tree2VolumeUI() {

			// Setup frame
			super("Cluster Viewer - ATLAS Toolkit");
			setSize(1024, 768);

			// Construct the Outline control for navigating clusterTree
			NodeRowModel nodeRowModel = new NodeRowModel();
			OutlineModel model = DefaultOutlineModel.createOutlineModel(clusterTree, nodeRowModel, true, " ");
			//Outline 
                        outline = new Outline();
                        // Control for displaying the heirarchical tree, complete with display options for each node
			outline.setRootVisible(true);
			outline.setModel(model);
			outline.setDefaultRenderer(Color.class, new ColorRenderer(true));
                        outline.setDefaultRenderer(Integer.class, new ProgressRenderer(true));
			outline.setDefaultEditor(Color.class, new ColorEditor() );
			TableColumn column = outline.getColumnModel().getColumn(2);
			column.setMaxWidth(30);
			column.setResizable(false);
			column = outline.getColumnModel().getColumn(1);
			column.setMaxWidth(30);
			column.setResizable(false);
			outline.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);///AUTO_RESIZE_OFF);outline.setRootVisible(false);
			outline.setShowGrid(true);
			outline.setGridColor(new Color(225,225,225) );
			outline.setRowSelectionAllowed(false);

			// Setup the 3D universe
			univ = new Image3DUniverse();
			univ.getCanvas().setMinimumSize(new Dimension(300, 300) );//(int) univ.getCanvas().getMinimumSize().getHeight() ) );
                        
                        // Set the bckground color for univ
                        Background background = ( (ImageCanvas3D) univ.getCanvas()).getBG();
                        background.setColor(new Color3f(backgroundColor) );
                        
                        JCheckBox animateCheckBox = new JCheckBox("Animate", false);
			animateCheckBox.addActionListener(new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent e) {
                                if (!animating) {
                                    animating = true;
                                    univ.startAnimation();
                                } else {
                                    animating = false;
                                    univ.pauseAnimation();
                                }
                            }
                        });
			
                        JButton xyButton = new JButton("xy");
                        xyButton.addActionListener(new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent e) {
                                univ.rotateToPositiveXY();
                            }
                        });
                        
                        JButton xzButton = new JButton("xz");
                        xzButton.addActionListener(new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent e) {
                                univ.rotateToPositiveXZ();
                            }
                        });
                        
                        JButton zyButton = new JButton("zy");
                        zyButton.addActionListener(new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent e) {
                                univ.rotateToPositiveYZ();
                            }
                        });
                        
                        JButton resetButton = new JButton("Reset View");
                        resetButton.addActionListener(new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent e) {
                                univ.getExecuter().resetView();
                            }
                        });
                        
                        final JButton backgroundButton = new JButton("Change Background");
			backgroundButton.addActionListener(new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent e) {
                                
                                // Setup a dialogue to get a color from the user
                                final JColorChooser colorChooser = new JColorChooser();
                                /*int panelCount = colorChooser.getChooserPanels().length;
                                for(int n = 0; n < panelCount; n++){
                                    AbstractColorChooserPanel[] panels = colorChooser.getChooserPanels();
                                    String displayName=panels[n].getDisplayName();
                                    colorChooser.removeChooserPanel(panels[n]);
                                    panelCount--;
                                    n = 0;
                                }*/
                                JDialog dialog = JColorChooser.createDialog(backgroundButton,
                                                                    "Pick a Color",
                                                                    true,  //modal
                                                                    colorChooser,
                                                                    new ActionListener () {  //OK button handler
                                                                        @Override
                                                                        public void actionPerformed(ActionEvent e) {
                                                                            // Set the bckground color for univ
                                                                            backgroundColor = colorChooser.getColor();
                                                                            Background background = ( (ImageCanvas3D) univ.getCanvas()).getBG();
                                                                            background.setColor(new Color3f(backgroundColor) );
                                                                            ((ImageCanvas3D) univ.getCanvas()).render();
                                                                        }
                                                                    },
                                                                    null); //no CANCEL button handler
                                colorChooser.setColor(backgroundColor);
				dialog.setVisible(true);
                            }
                        });
                        
                        JButton snapshotButton = new JButton("Snapshot");
                        snapshotButton.addActionListener(new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent e) {
                                Canvas3D canvas = univ.getCanvas();
                                Point p = canvas.getLocationOnScreen();
                                Rectangle bounds = new Rectangle(p.x, p.y, canvas.getWidth(), canvas.getHeight() );
                                try {
                                    Robot robot = new Robot(panel3d.getGraphicsConfiguration().getDevice() );
                                    Image img = robot.createScreenCapture(bounds);
                                    ImagePlus ip = new ImagePlus("Snapshot", img);
                                    ip.show();
                                } catch (Exception ex) {
                                    ex.printStackTrace();
                                }
                                
                            }
                        });
                        
			JButton openViewerButton = new JButton("Open in 3D Viewer");
			openViewerButton.addActionListener(new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent e) {
                                //univ.show();
                                //UI.close();
                                
                                // Need to create a new universe and populate it with new replicas of the currently visible objects
                                Image3DUniverse copyUniv = new Image3DUniverse();
                                Background background = ( (ImageCanvas3D) copyUniv.getCanvas()).getBG();
                                background.setColor(new Color3f(backgroundColor) );
                                // Iterate through all objects and add the visible objects to the new universe
                                IJ.showStatus("Copying 3D universe...");
                                int visibles = 0;
                                for (int i = 0; i < clusterTree.getNodeCount(); i++) {
                                    // Check if current node is shown
                                    IJ.showProgress(i, clusterTree.getNodeCount());
                                    if (clusterTree.getNodeAtIndex(i).isVisible() ) {
                                        // The current node is visible, so add it to the new universe
                                        //copyUniv.addContent(clusterTree.getNodeAtIndex(i).getContent() );
                                        //ImagePlus tempIP = clusterTree.getNodeAtIndex(i).getImagePlus();
                                        int resampling = 4;
                                        //IJ.log("#1");
                                        if (clusterTree.getNodeAtIndex(i).getParentIndex() == -1) {
                                            resampling = 12;
                                        }
                                        boolean[] channels = {true, true, true};
                                        //IJ.log("#2");
                                        //IJ.log("Adding \"" + clusterTree.getNodeAtIndex(i).toString() + "\" to duplicate universe...");
                                        //IJ.log("#3");
                                        //if (tempIP == null) IJ.log(clusterTree.getNodeAtIndex(i).toString() + ": ImagePlus == null");
                                        //tempIP.show();
                                        //clusterTree.getNodeAtIndex(i).getImagePlus().show();
                                        Content c = copyUniv.addMesh(clusterTree.getNodeAtIndex(i).getImagePlus(), // The ImagePlus
                                                new javax.vecmath.Color3f(clusterTree.getNodeAtIndex(i).getColor() ), // Color
                                                clusterTree.getNodeAtIndex(i).toString(), // Name
                                                50, // Threshold
                                                channels, // Which RGB channels to display
                                                resampling); // Resampling factor
                                        if (clusterTree.getNodeAtIndex(i).getParentIndex() == -1) {
                                            c.setShaded(false);
                                        }
                                        //IJ.log("...done!");
                                        visibles++;
                                    }
                                }
                                IJ.showStatus("Copying 3D universe...done! Found " + visibles);
                                copyUniv.show();
                            }
                        });
                        
                        WrapLayout wrap = new WrapLayout();
			JPanel controlPanel = new JPanel(wrap);
			controlPanel.add(animateCheckBox);
                        controlPanel.add(resetButton);
                        controlPanel.add(backgroundButton);
			controlPanel.add(snapshotButton);
                        controlPanel.add(openViewerButton);
                        BorderLayout layout = new BorderLayout();
			
                        // Set up panel3d 
                        panel3d = new JPanel(layout);
			panel3d.add(univ.getCanvas(), BorderLayout.CENTER);
			panel3d.add(controlPanel, BorderLayout.PAGE_END);

                        // Set up treePanel
                        treeView = new Dendrogram( (ClusterNode) clusterTree.getRoot() );
                        treeView.setBackground(new Color(255, 255, 255));
                        
                        // Set up the heatmap
                        heatmap = new HeatMap();
                        
                        // Set up treePanel split
                        JSplitPane treeSplit = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, treeView, heatmap);
                        
			// Establish the tabbed pane that appears on right side of usier interface
			JTabbedPane tabbedPane = new JTabbedPane();
			tabbedPane.addTab("3D View", panel3d );
			//JScrollPane paneTreeView = new JScrollPane(treeView);
                        //paneTreeView.add(treePanel);
			tabbedPane.addTab("Tree View", treeSplit);//heatmap);//treeView);

			// Add components
			JScrollPane leftScrollPane = new JScrollPane(outline);
			leftScrollPane.setMinimumSize( new Dimension(250,480) );
			JScrollPane rightScrollPane = new JScrollPane();
			JSplitPane jsp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, leftScrollPane, tabbedPane);
			jsp.setOneTouchExpandable(true);
			add(jsp);
                        
                        ClusterNode rootNode = (ClusterNode) clusterTree.getRoot();
                        rootNode.toggleVisible();
			
			setVisible(true);
                        treeSplit.setDividerLocation(0.25);
                        ij.IJ.setTool("Hand");
		}
	}

	// This Class defines the row information for each tree node in outline (part of UI)
	private class NodeRowModel implements RowModel {

		public Class getColumnClass(int column) {
			switch (column) {
				case 0 : return Boolean.class;
				case 1 : return Color.class;
                                case 2 : return Integer.class;
                                default : assert false;
			}
			return null;
		}
		
		public int getColumnCount() {
			return 3;
		}
		
		public String getColumnName(int column) {
			return column == 0 ? "" : "";
		}
		
		public Object getValueFor(Object node, int column) {
			ClusterNode c = (ClusterNode) node;
			switch (column) {
				case 0 : return c.isVisible();
				case 1 : return c.getColor();
                                case 2 : return c.getProgress();
                                default : assert false;
			}
			return null;
		}
	
		public boolean isCellEditable(Object node, int column) {
			return true;
		}
	
		public void setValueFor(Object node, int column, Object value) {
			ClusterNode c = (ClusterNode) node;
			if (column == 0) {
                            //if ( (c.getProgress() == -1) || (c.getProgress() >= 100) ) {
                            if (c.getParentIndex() == -1) {
                                // It's the root!
                                //IJ.log("setValueFor() called on root of NodeRowModel: value = " + (Boolean) value);
                                c.setVisible( (Boolean) value);
                            } else {
                                c.toggleVisible();
                            }
                            
                            //}
			} else if (column == 1) {
                            c.setColor( (Color) value);
			} else if (column == 2) {
                            c.setProgress( (Integer) value);
                        }
                        outline.repaint();
		}
	}

	// Class representing a single cluster tree node, replaces the old Node class
	private class ClusterNode {

		private boolean isVisible = false;
		private Color color;
                private String name;
		private int thisIndex;
		private int parentIndex = -1;
		private int[] childIndex = new int[2];
		private String[] childValue = new String[2];
		private double distance;
		private ImagePlus imp;
		private Content content;
                private int progress = -1;
                private int visibleChildren = 0;
                //private int visibleLevels = 0;
                private boolean drawNode = false; // Keeps track of whether this node should be included in a dendrogram
                private float[] mean = new float[geneCount];// = {1.0f, 1.0f, 1.0f, 1.0f, 1.0f};
                private float[][] childLevels = new float[2][geneCount];
                
		public ClusterNode(String name, int index) {
			this.name = name;
			this.color = Color.WHITE;
                        childIndex[0] = -1;
			childIndex[1] = -1;
			thisIndex = index;
		}
                
                // This method replaces the old reconstructVolume method
                private void createContent() {
                    String[] results = clusterTree.getLeafValues(thisIndex);
                    final int[][] coord_list = parseCoordinates(cluster_filepath, results);
                    final int[] finalBins = bins;
                    final String title = "Node" + (thisIndex + 1);
                    final int nodeIndex = thisIndex;
                    
                    // Use a SwingWorker to create the ImagePlus in the background
                    // Override the done() method to use the Imagelus to call setContent()
                    progress = 0;
                    final SwingWorker worker = new SwingWorker<ImagePlus, Void> () {
                        
                        boolean done = false;
                        
                        @Override
                        public ImagePlus doInBackground() {
                            
                            setProgress(1);
                            
                            // Calculate scaling
                            int[] size = intersection.getDimensions();
                            int xMultiplier = 1 + (size[0] / finalBins[0]);
                            int yMultiplier = 1 + (size[1] / finalBins[1]);
                            int zMultiplier = 1 + (size[3] / finalBins[2]);
                            
                            // Create an ImagePlus
                            ImagePlus ip = new ImagePlus();
                            ImageStack is = new ImageStack(size[0], size[1], size[3] );
                            
                            for (int z = 0; z < size[3]; z++) {
                                
                                is.setProcessor(new ByteProcessor(size[0], size[1]), z + 1 );
                            }
                            ip.setTitle(title);
                            ip.setStack(is);
                            
                            // Populate ImagePlus with white pixels according to the coord_list
                            for (int i = 0; i < coord_list.length; i++) {
                                
                                int currentProgress = 1 + (int) ( (  (float)i / (float)coord_list.length) * 100.0f);
                                setProgress(currentProgress);
                                for (int z = 0; z < zMultiplier; z++) {
                                    ip.setSlice((coord_list[i][2] * zMultiplier) + z);
                                    intersection.setSlice( (coord_list[i][2] * zMultiplier) + z);
                                    for (int x = 0; x < xMultiplier; x++) {
                                        for (int y = 0; y < yMultiplier; y++) {
                                            if (intersection.getProcessor().getPixel( (coord_list[i][0] * xMultiplier) + x, (coord_list[i][1] * yMultiplier) + y) > (256 / 2) ) {
                                                ip.getProcessor().set( (coord_list[i][0] * xMultiplier) + x, (coord_list[i][1] * yMultiplier) + y, 255);
                                            }
                                        }
                                    }
                                }
                            }
                            
                            setContent(ip);
                            
                            // Parse mean expression levels for arrys below this node
                            float[][] sumAndNs = calcMeans( clusterTree.getNodeAtIndex(nodeIndex) );
                            // Caculate means for each gene
                            for (int gene = 0; gene < geneCount; gene++) {
                                mean[gene] = sumAndNs[0][gene] / sumAndNs[1][gene];
                            }
                            return ip;
                        }
                        
                        @Override
                        public void done() {
                            
                            done = true;
                            try {
                                
                                progress = 100;
                            
                            } catch (Exception e) {}
                        }
                    };
                    worker.addPropertyChangeListener(
                        new PropertyChangeListener() {
                            
                            @Override
                            public void propertyChange(PropertyChangeEvent evt) {
                            
                                int progress = worker.getProgress();
                                setProgress(progress);
                                outline.repaint();
                            }
                        });
                    worker.execute();
                }
                
                // This method is called from SwingWorker.done() to process the resulting ImagePlus
                private void setContent(ImagePlus imp) {
                    
                    if (content != null) {
                        return;
                    }
                    
                    this.imp = imp;
                    Random rand = new Random();
                    int resampling = 4;
                    if (parentIndex == -1) {
                        // This is the root node
                        this.color = new Color(225, 225, 225);
                        resampling = 12;
                    } else {
                        this.color = Color.getHSBColor(rand.nextFloat(), 0.75f, 0.75f);
                    }
                    boolean[] channels = {true, true, true};
                    content = univ.addMesh( imp, // The ImagePlus
                                            new javax.vecmath.Color3f(this.color), // Color
                                            this.name, // Name
                                            50, // Threshold
                                            channels, // Which RGB channels to display
                                            resampling); // Resampling factor
                    content.setLocked(true);
                    if (parentIndex == -1) {
                        // This is the root node
                        content.setShaded(false);
                    }
                    setVisible(true);
                }
                
                // Returns the Content object held within this instance of ClusterNode
                public Content getContent() {
                    
                    if (content != null) {
                        return content;
                    }
                    return null;
                }
                
                // Returns the ImagePlus object held within this instance of ClusterNode
                public ImagePlus getImagePlus() {
                    
                    if (imp != null) {
                        return imp;
                    }
                    return null;
                }
                
                private float[][] calcMeans(ClusterNode node) {
                    
                    float[][] sumAndN = new float[2][geneCount];
                    float[][] temp = new float[2][geneCount];
                    for (int gene = 0; gene < geneCount; gene++) {
                        sumAndN[0][gene] = 0;
                        sumAndN[1][gene] = 0;
                    }
                    for (int child = 0; child < 2; child++) {
                        if (!node.childIsLeaf(child) ) {
                            // Child is a branch, so call calcMeans() on it ad add return values to sumAndN
                            temp = calcMeans(clusterTree.getNodeAtIndex(node.getChildIndex(child) ) );
                            for (int gene = 0; gene < geneCount; gene++) {
                                sumAndN[0][gene] = sumAndN[0][gene] + temp[0][gene];
                                sumAndN[1][gene] = sumAndN[1][gene] + temp[1][gene];
                            }
                        } else {
                            // Child is a leaf, so add its data to sumAndN
                            temp[0] = node.getChildLevels(child);
                            //IJ.log("temp[0].length = " + temp[0].length);
                            for (int gene = 0; gene < geneCount; gene++) {
                                sumAndN[0][gene] = sumAndN[0][gene] + temp[0][gene];
                                sumAndN[1][gene]++;
                            }
                        }
                    }
                    //IJ.log("sumAndN[0].length = " + sumAndN[0].length);
                    return sumAndN;
                }

		public String toString() {
			return this.name;
		}

		public void setColor(Color newColor) {
			this.color = newColor;
			if (content != null) {
				univ.getContent(this.name).setColor( new javax.vecmath.Color3f(this.color) );
			}
		}
                
                public boolean getNodeIsDrawn() {
                    return drawNode;
                }
                
                public void setNodeIsDrawn(boolean draw) {
                    // Only call after updating the number of visible children in the tree
                    
                    // Update whether this node is drawn in the dendrogram
                    drawNode = draw;


                    // If this is not the root node...
                    if (parentIndex != -1) {

                        // Check if this affects the parent
                        ClusterNode parent = clusterTree.getNodeAtIndex(parentIndex);

                        // Check if parent's left branch has visible children:
                        boolean visibleLeft = false;
                        int indexLeftOfParent = parent.getLeftIndex();
                        // If parent has a left child ...
                        if (indexLeftOfParent != -1) {
                            ClusterNode nodeLeftOfParent = clusterTree.getNodeAtIndex(indexLeftOfParent);
                            // ...and if the left child is visible OR has visible children...
                            if (nodeLeftOfParent.isVisible() || (nodeLeftOfParent.getVisibleChildCount() > 0) ) {
                                // ...then the parent's left branch is visible
                                visibleLeft = true;
                            }
                        }

                        // Check if parent's right branch has visible children:
                        boolean visibleRight = false;
                        int indexRightOfParent = parent.getRightIndex();
                        // If parent has a right child ...
                        if (indexRightOfParent != -1) {
                            ClusterNode nodeRightOfParent = clusterTree.getNodeAtIndex(indexRightOfParent);
                            // ...and if the right child is visible OR has visible children...
                            if (nodeRightOfParent.isVisible() || (nodeRightOfParent.getVisibleChildCount() > 0) ) {
                                // ...then the parent's right branch is visible
                                visibleRight = true;
                            }
                        }

                        // If the parent's left AND right branches are both visible...
                        if (visibleLeft && visibleRight) {
                            // ...then the parent node should be drawn in the dendrogram
                            parent.setNodeIsDrawn(true);
                        } else {
                            // ...otherwise the parent should not be drawn in the dendrogram
                            parent.setNodeIsDrawn(false);
                        }
                    }
                }
                
                public float[] getChildLevels(int child) {
                    return childLevels[child];
                }
                
                public void setChildLevels(int child, float[] levels) {
                    childLevels[child] = levels;
                }
                
                public float[] getMeans() {
                    if (mean == null) {
                        IJ.log("mean == null");
                    }
                    return mean;
                }
                
                public void setMeans(float[] m) {
                    mean = m;
                }
                
		public void setVisible(boolean isVisible) {
			if (content != null) {
                            
                            if (this.isVisible) {
                                // This node is  visible...
                                if (!isVisible) {
                                    // ...and want to make it invisible
                                    content.setVisible(false);
                                    this.isVisible = false;
                                    clusterTree.getNodeAtIndex(parentIndex).decrementVisibleChildCount();
                                    // Lastly set whether this node is drawn
                                    setNodeIsDrawn(false);
                                }
                            } else {
                                // This node is invisible...
                                if (isVisible) {
                                    // ...and want to make it visible
                                    content.setVisible(true);
                                    this.isVisible = true;
                                    // If this is not the root node...
                                    if (parentIndex != -1) {
                                        
                                        clusterTree.getNodeAtIndex(parentIndex).incrementVisibleChildCount();
                                        
                                        // ...hide all parents above this node...
                                        clusterTree.getNodeAtIndex(parentIndex).hideParents();
                                        
                                        // If there is a left child...
                                        if (childIndex[0] != -1) {
                                            // ...hide it and its children
                                            clusterTree.getNodeAtIndex(childIndex[0]).hideChildren();
                                        }
                                        // If there is a right child...
                                        if (childIndex[1] != -1) {
                                            // ...hide it and its children
                                            clusterTree.getNodeAtIndex(childIndex[1]).hideChildren();
                                        }
                                        // Lastly set whether this node is drawn
                                        setNodeIsDrawn(true);
                                    }
                                }
                            }
                            treeView.repaint();
                        }
		}

		public boolean isVisible() {
			return this.isVisible;
		}

		public void toggleVisible() {

			if (content == null) {
                            // There is not content so make some
                            createContent();
			} else {
                            // Togggle visibility
                            setVisible( !isVisible );
                            outline.repaint();
                        }
		}
                
                public void incrementVisibleChildCount() {
                    // The number of visible children below this node has increased by 1
                    
                    visibleChildren++;
                    if (parentIndex != -1) {
                        clusterTree.getNodeAtIndex(parentIndex).incrementVisibleChildCount();
                    }
                }
                
                public void decrementVisibleChildCount() {
                    // The number of visible children below this node has decreased by 1
                    
                    visibleChildren--;
                    if (parentIndex != -1) {
                        clusterTree.getNodeAtIndex(parentIndex).decrementVisibleChildCount();
                    }
                }
                
                private void hideParents() {
                    // If parent is not the root node...
                    if (parentIndex != -1) {
                        // ...and if there is some content to hide...
                        if ( (content != null) ) {
                            // ...hide it!
                            setVisible(false);
                        }
                        clusterTree.getNodeAtIndex(parentIndex).hideParents();
                    }
                }
                
                private void hideChildren() {
                    // If there is some content to hide...
                    if ( (content != null) ) {
                        // ...hide it!
                        setVisible(false);
                    }
                    // If there are visible children...
                    if (this.visibleChildren > 0) {
                        // If there is a left child...
                        if (childIndex[0] != -1) {
                            // ...hide it and its children
                            clusterTree.getNodeAtIndex(childIndex[0]).hideChildren();
                        }
                        // If there is a right child...
                        if (childIndex[1] != -1) {
                            // ...hide it and its children
                            clusterTree.getNodeAtIndex(childIndex[1]).hideChildren();
                        }
                    }
                }

		public Color getColor() {
			return color;
		}
                
                public int getProgress() {
                    return progress;
                }
                
                public void setProgress(int value) {
                    progress = value;
                }

		public int[] getChildren() {
                    return childIndex;
		}

		// Methods carried over from old Node class
		public void setParentIndex(int index) {
			parentIndex = index;
		}

		public void setDistance(double distance) {
			this.distance = distance;
		}
                
                public String getChildValue(int child) {
                    return childValue[child];
                }
                
                public void setChildValue(int child, String value) {
                    childValue[child] = value;
                }
                
                public int getChildIndex(int child) {
                    return childIndex[child];
                }
                
                public void setChildIndex(int child, int index) {
                    childIndex[child] = index;
                }
                
                public boolean childIsLeaf(int child) { 
                    if (getChildIndex(child) == -1) {
                        return true;
                    } else {
                        return false;
                    }
                }

		public void setLeftValue(String value) {
			childValue[0] = value;
		}

		public void setLeftIndex(int index) {
			childIndex[0] = index;
		}

		public void setRightValue(String value) {
			childValue[1] = value;
		}

		public void setRightIndex(int index) {
			childIndex[1] = index;
		}

		public int getParentIndex() {
			return parentIndex;
		}

		public double getDistance() {
			return distance;
		}
		
		public String getLeftValue() {
			return childValue[0];
		}

		public int getLeftIndex() {
			return childIndex[0];
		}

		public String getRightValue() {
			return childValue[1];
		}

		public int getRightIndex() {
			return childIndex[1];
		}

		public boolean leftIsLeaf() {
			//return false;
			if (getLeftIndex() == -1) {
				return true;
			} else {
				return false;
			}
		}

		public boolean rightIsLeaf() {
			if (getRightIndex() == -1) {
				return true;
			} else {
				return false;
			}
		}

		public int countChildren() {// Returns the number of immediate children
                    int childCount = 0;
                    if (getLeftIndex() != -1) childCount++;
                    if (getRightIndex() != -1) childCount++;
                    return childCount;
		}
                
                public int getVisibleChildCount() {
                    // Returns the number of visible children beneath this node
                    // Be sure to call countVisibleChildren on the root node to ensure an accurate return value
                    return visibleChildren;
                }
                
                public int getLastVisibleParentIndex() {
                    // Returns the index of the last visible parent of the current node, or -1 if there is none
                    int lastVisibleParent = -1;
                    if (parentIndex != -1) {
                        ClusterNode nextParent = clusterTree.getNodeAtIndex(parentIndex);
                        while ( ! (nextParent.getVisibleChildCount() > this.getVisibleChildCount() ) ) {
                            lastVisibleParent = nextParent.getParentIndex();
                            nextParent = clusterTree.getNodeAtIndex(lastVisibleParent);
                        }
                    }
                    return lastVisibleParent;
                }
                
                public int getLevelsToDraw() {
                    // Returns the maximum number of levels to be drawn under this node (inclusive)
                    int visibleLevels = 0;
                    // If the current node is to be drawn...
                    if (getNodeIsDrawn() ) {
                        // ...increment visibleLevels by one
                        visibleLevels++;
                    }
                    int leftLevels = 0;
                    // If there is a left child...
                    if (childIndex[0] != -1) {
                        // ...get the maximum number of levels to be drawn under the left child (inclusive)
                        leftLevels = leftLevels + clusterTree.getNodeAtIndex(childIndex[0]).getLevelsToDraw();
                    }
                    int rightLevels = 0;
                    // If there is a right child...
                    if (childIndex[1] != -1) {
                        // ...get the maximum number of levels to be drawn under the right child (inclusive)
                        rightLevels = rightLevels + clusterTree.getNodeAtIndex(childIndex[1]).getLevelsToDraw();
                    }
                    // Increment visibleLevels by the maximum number of levels to be drawn under this one (exclusive)
                    visibleLevels = visibleLevels + Math.max(leftLevels, rightLevels);
                    return visibleLevels;
                }
	}

	// Class for holding the cluster tree data, replaces the old TreeProcessor class
	private class ClusterTreeModel implements TreeModel {
                private ClusterNode[] node;
                // Constructor
		public ClusterTreeModel(String tree_filepath) {
                        // Open tree file
			BufferedInputStream buffer;
			try {
				// Count the number nodes by counting the number of '/n' characters in the input .atr file
				buffer = new BufferedInputStream(new FileInputStream(tree_filepath));
				byte[] chunk = new byte[1024];
				int node_count = 0;
				int readChars = 0;
				boolean empty = true;
				while ((readChars = buffer.read(chunk)) != -1) {
                                    empty = false;
                                    for (int i = 0; i < readChars; ++i) {
                                        if (chunk[i] == '\n') ++node_count;
                                    }
				}
				buffer.close();
                                // Make an array for storing nodes
				node = new ClusterNode[node_count];
                                // Read nodes, line by line
				LineNumberReader reader  = new LineNumberReader(new FileReader(tree_filepath));
				String line = "";
				while ( (line = reader.readLine() ) != null ) {
                                        // Parse node index
					int index = 0;
					char c;
					String word = "";
					while ( (c = line.charAt(index)) != 'X' ) {
                                            word = word + c;
                                            index++;
					}
					int node_index = Integer.parseInt( word.substring(4, word.length() ) ) - 1;
                                        // Create a new node at the current index
					node[node_index] = new ClusterNode(word, node_index);
                                        // Parse left child
					word = "";
					index = index + 2;
					while ( (c = line.charAt(index)) != 'X' ) {
                                            word = word + c;
                                            index++;
					}
                                        int left_child = Integer.parseInt( word.substring(4, word.length() ) ) - 1;
                                        if (word.startsWith("NODE") ) {
                                            // Child is node
                                            node[node_index].setLeftIndex(left_child);
                                            node[left_child].setParentIndex(node_index);
					} else {
                                            // Child is leaf
                                            node[node_index].setLeftValue(word);
					}
                                        // Parse right child
					word = "";
					index = index + 2;
					while ( (c = line.charAt(index)) != 'X' ) {
                                            word = word + c;
						index++;
					}
                                        int right_child = Integer.parseInt( word.substring(4, word.length() ) ) - 1;
					if (word.startsWith("NODE") ) {
                                            // Child is node
                                            node[node_index].setRightIndex(right_child);
                                            node[right_child].setParentIndex(node_index);
					} else {
                                            // Child is leaf
                                            node[node_index].setRightValue(word);
					}
                                        // Parse distance
					index = index + 2;
					word = line.substring(index, line.length() );
					node[node_index].setDistance( Double.parseDouble( line.substring(index, line.length() ) ) );
				}
				reader.close();
			} catch(IOException e) {
                            IJ.showMessage("Error", "Cannot find file!");
			}
                        parseLevels();
		}
                
                private void parseLevels() {
                    // Read ARRY header line and gene expression data from .cdt file
                    String arryHeader = "";
                    String[] geneData = new String[geneCount];
                    try {
                        LineNumberReader reader  = new LineNumberReader(new FileReader(cluster_filepath));
                        reader.readLine(); // Discard first header line
                        arryHeader = reader.readLine();
                        reader.readLine(); // Discard third line
                        for (int gene = 0; gene < geneCount; gene++) {
                            geneData[gene] = reader.readLine(); // Read data gene line
                        }
                        reader.close();
                    } catch(IOException e) {
                        IJ.showMessage("Error", "Cannot find file!");
                    }
                    // Count number of tabs in arryHeader
                    int tabCount = 1;
                    for (int index = 0; index < arryHeader.length(); index++) {
                        char c = arryHeader.charAt(index);
                        if (c == '\t') {
                            tabCount++;
                        }
                    }
                    // Parse ARRY names and expression levels into a set of String arrays
                    String[] header = new String[tabCount];
                    String[][] geneLevels = new String[geneCount][tabCount];
                    tabCount = 0;
                    for (int index = 0; index < arryHeader.length(); index++) {
                        String word = "";
                        char c;
                        while ( (index < arryHeader.length() ) &&
                                ( (c = arryHeader.charAt(index) ) != '\t' ) ) {
                            word = word + c;
                            index++;
                        }
                        header[tabCount] = word;
                        tabCount++;
                    }
                    for (int gene = 0; gene < geneCount; gene++) {
                        tabCount = 0;
                        for (int index = 0; index < geneData[gene].length(); index++) {
                            String word = "";
                            char c;
                            while ( (index < geneData[gene].length() ) &&
                                    ( (c = geneData[gene].charAt(index) ) != '\t' ) ) {
                                word = word + c;
                                index++;
                            }
                            geneLevels[gene][tabCount] = word;
                            tabCount++;
                        }
                    }
                    // OK, so now all the input data has been parsed into these two string arrays
                    for (int n = 0; n < node.length; n++) {
                        IJ.showStatus("Parsing Levels...");
                        IJ.showProgress(n, node.length);
                        // If the node's children are leaves...
                        for (int child = 0; child < 2; child++) {
                            if (node[n].childIsLeaf(child) ) {
                                // Search the header array for to find index into the geneLevels array
                                int arryIndex = 0;
                                for (int index = 0; index < header.length; index++) {
                                    if (header[index].contains( node[n].getChildValue(child) ) ) {
                                        // Found a match
                                        arryIndex = index;
                                        index = header.length; // Escape for loop
                                    }
                                }
                                // OK, so found index into geneLevels array, so copy data over
                                float[] levels = new float[geneCount];
                                for (int gene = 0; gene < geneCount; gene++) {
                                    levels[gene] = Float.parseFloat( geneLevels[gene][arryIndex] );
                                }
                                node[n].setChildLevels(child, levels);
                            }
                        }
                    }
                }

		// This method returns the number of nodes in the tree
		public int getNodeCount() {

			return node.length;
		}
                
                public ClusterNode getNodeAtIndex(int index) {
                    
                    return node[index];
                }

		// This method traverses the tree to produce a list of leaves beneath the given node
		public String[] getLeafValues(int node_index) {

			String[] temp_results = new String[ bins[0] * bins[1] * bins[2] ];

			// Create a stack
			Stack<ClusterNode> node_stack = new Stack<ClusterNode>();

			// Push the current node onto the stack
			node_stack.push(node[node_index]);

			int leafCount = 0;

			// Iterate through the tree
			while ( ! node_stack.empty() ) {

				// Pop a node from the top of the stack
				ClusterNode current_node = node_stack.pop();

				// Check the node's right child
				if ( current_node.rightIsLeaf() ) {

					// Right child is a leaf, so print value to log
					temp_results[leafCount] = current_node.getRightValue();
					leafCount++;
				} else {

					// Right child is a node, so push it onto the stack
					node_stack.push( node[ current_node.getRightIndex() ] );
				}

				// Check the node's left child
				if ( current_node.leftIsLeaf() ) {

					// Left child is a leaf, so print value to log
					temp_results[leafCount] = current_node.getLeftValue();
					leafCount++;
				} else {

					// Left child is a node, so push it onto the stack
					node_stack.push( node[ current_node.getLeftIndex() ] );
				}
			}
			String[] results = new String[leafCount];
			for (int i = 0; i < leafCount; i++) {

				results[i] = temp_results[i];
			}
			return results;
		}

		//The following methods implement the TreeModel interface
		@Override
		public void addTreeModelListener(javax.swing.event.TreeModelListener l) {
			//do nothing
		}

		@Override
		public Object getChild(Object parent, int index) {
			// Returns one of the parent node's two children
			ClusterNode c = (ClusterNode) parent;
			if (c.countChildren() == 2) {
				if (index == 0) {
					return node[c.getLeftIndex()];
				} else if (index == 1) {
					return node[c.getRightIndex()];
				}
			} else if (c.countChildren() == 1) {
				if (index == 0) {
					if (c.getLeftIndex() != -1) {
						return node[c.getLeftIndex()];
					} else if (c.getRightIndex() != -1) {
						return node[c.getRightIndex()];
					} else {
						return null;
					}
				}
			}
			return null;
		}

		@Override
		public int getChildCount(Object parent) {
			// Returns the number of nodes beneath the given node
			ClusterNode c = (ClusterNode) parent;
			return c.countChildren();
		}

		@Override
		public int getIndexOfChild(Object parent, Object child) {
			// Returns index of given child node in parent node
			ClusterNode par = (ClusterNode) parent;
			ClusterNode ch = (ClusterNode) child;
			
			int inChildIndexInParent = 0;
			if (par.countChildren() == 2) {
				if ( ch.equals( node[ par.getLeftIndex() ] ) ) {
					inChildIndexInParent = 0;
				} else if ( ch.equals( node[ par.getRightIndex() ] ) ) {
					inChildIndexInParent = 1;
				}
			} else if (par.countChildren() == 1) {
				inChildIndexInParent = 0;
			}
			return inChildIndexInParent;
		}

		@Override
		public Object getRoot() {
			// The root node is always the last in the .atr file and therefore also in the node[]
			return node[node.length - 1];
		}

		@Override
		public boolean isLeaf(Object node) {
			ClusterNode c = (ClusterNode) node;
			boolean isLeaf = false;
			if ( c.leftIsLeaf() && c.rightIsLeaf() ) {
				isLeaf = true;	// Both children are leaves, so for the purposes of this method the node is a leaf (i.e. there are no other nodes below it).
			}
			return false;
		}

		@Override
		public void removeTreeModelListener(javax.swing.event.TreeModelListener l) {
			//do nothing
		}

		@Override
		public void valueForPathChanged(javax.swing.tree.TreePath path, Object newValue) {
			//do nothing
		}
	}
        
    // Handles progress rendering 
    public class ProgressRenderer extends DefaultTableCellRenderer {
        //...
        //JProgressBar b = new JProgressBar(-1, 100);
        boolean isBordered = true;
        public ProgressRenderer(boolean isBordered) {
            super();
            setOpaque(true);
            //b.setBorder(BorderFactory.createEmptyBorder(1,1,1,1));
        }
        
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            Integer i = (Integer)value;
            String text = "Done";
            if (i < 0) {
                //text = "Canceled";
                //b.setIndeterminate(false);
                //b.setValue(0);
                //outline.repaint();
                text = "";
                //return b;
            } else if (i < 100) {
                //b.setIndeterminate(true);
                //b.setValue(i);
                //outline.repaint();
                text = "Working...";
                //return b;
            }
            super.getTableCellRendererComponent(table, text, isSelected, hasFocus, row, column);
            return this;
        }
    }

    // Handles color property rendering (part of UI)
    public class ColorRenderer extends JLabel implements TableCellRenderer {
        //...
        boolean isBordered = true;
        public ColorRenderer(boolean isBordered) {
            this.isBordered = isBordered;
            setOpaque(true); //MUST do this for background to show up.
            Dimension d = getMaximumSize();
            d.setSize(d.getHeight(), d.getHeight());
            setMaximumSize(d);
        }
        
        public Component getTableCellRendererComponent(JTable table, Object color, boolean isSelected, boolean hasFocus, int row, int column) {
            Color newColor = (Color)color;
            setBackground(newColor);
            if (isBordered) {
                if (isSelected) {
                    Border selectedBorder = BorderFactory.createMatteBorder(2,5,2,5,table.getSelectionBackground());
                    setBorder(selectedBorder);
                } else {
                    Border unselectedBorder = BorderFactory.createMatteBorder(2,5,2,5,table.getBackground());
                    setBorder(unselectedBorder);
                }
            }
            //setToolTipText
            setToolTipText("RGB value: " + newColor.getRed() + ", " + newColor.getGreen() + ", " + newColor.getBlue());
            return this;
        }
    }

    // Handles color property editing (part of UI)
    public class ColorEditor extends AbstractCellEditor implements TableCellEditor, ActionListener {
		Color currentColor;
		JButton button;
		JColorChooser colorChooser;
		JDialog dialog;
		protected static final String EDIT = "edit";

		public ColorEditor() {
			button = new JButton();
			button.setActionCommand(EDIT);
			button.addActionListener(this);
			button.setBorderPainted(false);

			//Set up the dialog that the button brings up.
			colorChooser = new JColorChooser();
			/*int panelCount = colorChooser.getChooserPanels().length;
			for(int n = 0; n < panelCount; n++){
				AbstractColorChooserPanel[] panels = colorChooser.getChooserPanels();
				String displayName=panels[n].getDisplayName();
				colorChooser.removeChooserPanel(panels[n]);
                                panelCount--;
                                n = 0;
			}*/
			dialog = JColorChooser.createDialog(button,
                                                            "Pick a Color",
                                                            true,  //modal
                                                            colorChooser,
                                                            this,  //OK button handler
                                                            null); //no CANCEL button handler
		}

		public void actionPerformed(ActionEvent e) {
			if (EDIT.equals(e.getActionCommand())) {
				//The user has clicked the cell, so
				//bring up the dialog.
				button.setBackground(currentColor);
				colorChooser.setColor(currentColor);
				dialog.setVisible(true);

				fireEditingStopped(); //Make the renderer reappear.

			} else { //User pressed dialog's "OK" button.
				currentColor = colorChooser.getColor();
			}
		}

		//Implement the one CellEditor method that AbstractCellEditor doesn't.
		public Object getCellEditorValue() {
			return currentColor;
		}

		//Implement the one method defined by TableCellEditor.
		public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
			currentColor = (Color)value;
			return button;
		}
	}
    
    // This methods parses the .cdt file to determine how many genes there are
    private void parseGenes(String cdt_filepath) {
        try {
            // Count the number of lines following the first 3 header lines of the .cdt file
            LineNumberReader reader  = new LineNumberReader(new FileReader(cdt_filepath));
            String line = "";
            // Discard the first three header lines
            for (int i = 0; i < 3; i++) {
                line = reader.readLine();
            }
            while (line != null) {
                line = reader.readLine();
                geneCount++;
            }
            geneCount--; // The last line of .cdt file is empty
            geneName = new String[geneCount];
            reader.close();
            // Parse gene names from each line following the first 3 header lines of the .cdt file
            reader  = new LineNumberReader(new FileReader(cdt_filepath));
            // Discard the first three header lines
            for (int i = 0; i < 3; i++) {
                line = reader.readLine();
            }
            // Parse the gene name from each line
            for (int gene = 0; gene < geneCount; gene++) {
                line = reader.readLine();
                char c;
                int index = 0;
                String word = "";
                while ( ( c = line.charAt(index) ) != '\t' ) {
                    word = word + c;
                    index++;
                }
                geneName[gene] = word;
                //IJ.log(word);
            }
            reader.close();
        } catch(IOException e) {
            IJ.showMessage("Error", "Cannot find file!");
        }
    }
    
    // This methods directly sets the values in the global int[] bins, which keeps track of the number of bins in x, y and z.
    private void parseBinSize(String cdt_filepath) {
        try {
            // Count the number of tabs on the first line of the given .cdt file
            LineNumberReader reader  = new LineNumberReader(new FileReader(cdt_filepath));
            String line = reader.readLine();
            int tab_count = 0;
            int first_tab = 0;
            int index = 0;
            while ( index < line.length() ) {
                if (line.charAt(index) == '\t') {           // Have found a tab
                    tab_count++;                            // Increment the number of tabs counted
                    if (tab_count == 1) first_tab = index;  // Set a pointer to the first tab. ??? The first_tab == 1 here ensures that the preceeding GID/t in .gtr files is skipped over. Should be changed to first_tab == 0 for .atr files that have no preceeding GID/t
		}
                index++;
            }
            reader.close();
            int arry_count = tab_count - 4;
            // Parse the number of x, y, z bins
            // Parse x bins
            index = 0;//first_tab +1; // Should be changed to index = 0 for .cdt files that have no preceeding GID/t
            char c;
            String word = "";
            while ( ( c = line.charAt(index) ) != 'x' ) {
                word = word + c;
                index++;
            }
            bins[0] = Integer.parseInt(word); // Set the number of x bins
            index++;
            word = "";
            while ( ( c = line.charAt(index) ) != 'x' ) {
                word = word + c;
                index++;
            }
            bins[1] = Integer.parseInt(word); // Set the number of y bins
            // Parse z bins
            index++;
            word = "";
            while ( ( c = line.charAt(index) ) != '\t' ) {
                word = word + c;
                index++;
            }
            bins[2] = Integer.parseInt(word); // Set the number of z bins
            reader.close();
        } catch(IOException e) {
            IJ.showMessage("Error", "Cannot find file!");
        }
    }
    
    private int[][] parseCoordinates(String cdt_filepath, String[] bin_labels) {
        int tab_count = 0;
        int arry_count = 0;
        int[][] parsed_coord_list = new int[bin_labels.length][3];
        if (arry_mapping == null) {
            // Mapping has not been created
            // Count the number of arrays/coords that need to be mapped
            // Open cdt file
            BufferedInputStream buffer;
            try {
                // Count the number of tabs on the first line
                LineNumberReader reader  = new LineNumberReader(new FileReader(cdt_filepath));
                String line = reader.readLine();
                tab_count = 0;
                int first_tab = 0;
                int index = 0;
                while ( index < line.length() ) {
                    if (line.charAt(index) == '\t') {
                        tab_count++;
                        if (tab_count == 1) first_tab = index;
                    }
                    index++;
                }
                reader.close();
                arry_count = tab_count - 4;
                // Parse the number of x, y, z bins
                // Parse x bins
                index = 0;//first_tab+1;
                char c;
                String word = "";
                while ( ( c = line.charAt(index) ) != 'x' ) {
                    word = word + c;
                    index++;
                }
                bins[0] = Integer.parseInt(word);
                // Parse y bins
                index++;
                word = "";
                while ( ( c = line.charAt(index) ) != 'x' ) {
                    word = word + c;
                    index++;
                }
                bins[1] = Integer.parseInt(word);
                // Parse z bins
                index++;
                word = "";
                while ( ( c = line.charAt(index) ) != '\t' ) {
                    word = word + c;
                    index++;
                }
                bins[2] = Integer.parseInt(word);
                // Create an array for mapping arry:coord
                arry_mapping = new String[arry_count][2];	// 0 = coord, 1 = arry
                // Re-open .cdt file and read first line which contains the coord data
                reader  = new LineNumberReader(new FileReader(cdt_filepath));
                line = reader.readLine();
                // Skip over the first 4 tabs to find index of first coord within the file
                tab_count = 0;
                index = 0;
                while ( tab_count < 4 ) {
                    if (line.charAt(index) == '\t') tab_count++;
                    index++;
                }
                index--;
                // Iterate through coords
                int current_arry = 0;
                while ( (current_arry < arry_mapping.length) && ( index < line.length() ) ) {
                    // Get the next word and add to arry_mapping
                    word = "";
                    index = index + 1;
                    while ( (current_arry < arry_mapping.length) && ( index < line.length() ) && ( (c = line.charAt(index)) != '\t' ) ) {
                        word = word + c;
                        index++;
                    }
                    arry_mapping[current_arry][0] = word;
                    current_arry++;
                }
                // Read the second line which contains the arry data
                line = reader.readLine();
                // Skip over the first 4 tabs to find index of first arry
                tab_count = 0;
                index = 0;
                while ( tab_count < 4 ) {
                    if (line.charAt(index) == '\t') tab_count++;
                    index++;
                }
                index--;
                // Iterate through arrys
                current_arry = 0;
                while ( (current_arry < arry_mapping.length) && ( index < line.length() ) ) {
                    // Get the next word and add to arry_mapping
                    word = "";
                    index = index + 1;
                    while (  (current_arry < arry_mapping.length) && ( index < line.length() ) && ( (c = line.charAt(index)) != 'X' ) ) {
                        word = word + c;
                        index++;
                    }
                    arry_mapping[current_arry][1] = word;
                    current_arry++;
                    index++;	// This increment is needed to push index past the tab that follows the 'X'
                }
                reader.close();
            } catch(IOException e) {
                IJ.showMessage("Error", "Cannot find file!");
            }
        }
        // Now that we have a mapping, find each ARRY in arry_mapping to determine it's coord, 
        // then parse the coord to get x, y, z coordinates
        // Build a list of x, y, z coordinates and return it
        // Iterate through bin_labels
        for (int i = 0; i < bin_labels.length; i++) {
            // For each bin_label iterate through arry_mapping
            for (int j = 0; j < arry_mapping.length; j++) {
                // Check if current bin_label matches current arry_mapping
                if ( bin_labels[i].equals(arry_mapping[j][1]) ) {
                    // Found a match!
                    // Parse coord to detemine x, y, z coordinates...
                    // Parse x coordinate
                    int index = 0;
                    char c;
                    String word = "";
                    while (( index < arry_mapping[j][0].length() ) && ( ( c = arry_mapping[j][0].charAt(index) ) != 'x') ) {
                        word = word + c;
                        index++;
                    }
                    parsed_coord_list[i][0] = Integer.parseInt(word);
                    // Parse y coordinate
                    index++;
                    word = "";
                    while (( index < arry_mapping[j][0].length() ) && ( ( c = arry_mapping[j][0].charAt(index) ) != 'x') ) {
                        word = word + c;
                        index++;
                    }
                    parsed_coord_list[i][1] = Integer.parseInt(word);
                    // Parse z coordinate
                    index++;
                    word = "";
                    while ( ( index < arry_mapping[j][0].length() ) && ( ( c = arry_mapping[j][0].charAt(index) ) != 'x') ) {
                        word = word + c;
                        index++;
                    }
                    parsed_coord_list[i][2] = Integer.parseInt(word);
                }
            }
        }
        return parsed_coord_list;
    }
    
    private class Dendrogram extends JPanel {
        
        private int margin = 25;
        private int leaves;
        private int levels;
        private int heightPerLeaf;
        private int widthPerLevel;
        private int currentY;
        private ClusterNode root;
        private int squareSize = 20;
        
        public Dendrogram(ClusterNode root) {
            this.root = root;
        }
        
        @Override
        protected void paintComponent(Graphics gr) {
            super.paintComponent(gr);
            Graphics2D g = (Graphics2D) gr;
            leaves = root.getVisibleChildCount();
            levels = root.getLevelsToDraw();
            heightPerLeaf = (getHeight() - (2 * margin)) / (leaves);//) - 1);
            widthPerLevel = (getWidth()  - (2 * margin)) / (levels - 1);
            currentY = 0;
            map = new float[leaves][geneCount];
            draw(g, root, 0);
            heatmap.repaint();
        }
        
        public Point draw(Graphics g, ClusterNode node, int y) {
            boolean leftToDraw = false;
            if (node.getLeftIndex() != -1) {
                if ( (clusterTree.getNodeAtIndex( node.getLeftIndex() ).getNodeIsDrawn() ) ||
                     (clusterTree.getNodeAtIndex( node.getLeftIndex() ).getVisibleChildCount() > 0) ) {
                    leftToDraw = true;
                }
            }
            // Check if there is a right branch to draw:
            boolean rightToDraw = false;
            if (node.getRightIndex() != -1) {
                if ( (clusterTree.getNodeAtIndex( node.getRightIndex() ).getNodeIsDrawn() ) ||
                     (clusterTree.getNodeAtIndex( node.getRightIndex() ).getVisibleChildCount() > 0) ) {
                    rightToDraw = true;
                }
            }
            if ( ! (leftToDraw || rightToDraw)) {
                // If neither branch is drawn...
                // ...this is a leaf so return a point at the left edge of the dendrogram
                map[currentY] = node.getMeans();
                int x = getWidth() - margin;
                int resultX = x;
                int resultY = margin + (currentY * heightPerLeaf) + (int) (0.5f * heightPerLeaf);
                currentY++;// += heightPerLeaf;
                Point p = new Point(resultX, resultY);
                g.setColor(node.color);
                g.fillRect(p.x-(squareSize/2), p.y-(squareSize/2), squareSize, squareSize);
                p.x = p.x - (squareSize/2); // Make sure line isn't drawn over square
                return p;
            } else if ( (leftToDraw && rightToDraw) ) {
                // ...else if both branches are drawn...
                // ...this is a branching node so return a point were x reflects level and y is midway between children
                ClusterNode leftChild = clusterTree.getNodeAtIndex( node.getLeftIndex() );
                ClusterNode rightChild = clusterTree.getNodeAtIndex( node.getRightIndex() );
                Point pLeft = draw(g, leftChild, y); // Position of left child
                Point pRight = draw(g, rightChild, y + heightPerLeaf); // Position of right child
                int dx = widthPerLevel;
                int vx = Math.min(pLeft.x-dx, pRight.x-dx);
                g.setColor(Color.BLACK);
                g.drawLine(vx, pLeft.y, pLeft.x, pLeft.y); // Horizontal line to left child
                g.drawLine(vx, pRight.y, pRight.x, pRight.y); // Horizontal line to right child
                g.drawLine(vx, pLeft.y, vx, pRight.y); // Verticle line connecting children
                Point p = new Point(vx, pRight.y - (pRight.y - pLeft.y) / 2); // Position of this branching node
                return p; // Return position of this branching node
            } else {
                // ...otherwise return the position of the next node to be drawn
                if (leftToDraw) {
                    return draw(g, clusterTree.getNodeAtIndex( node.getLeftIndex() ), y);
                } else if (rightToDraw) {
                    return draw(g, clusterTree.getNodeAtIndex( node.getRightIndex() ), y);
                }
            }
            // Should never happen
            return new Point();
        }
    }
    
    private class HeatMap extends JPanel {
        
        private int margin = 25;
        private int leaves;
        private int availableWidth;
        private int heightPerLeaf;
        private int widthPerGene;
        private int currentY;
        private int geneX;
        private ClusterNode root;
        //private byte[] reds = new byte[256];
        //private byte[] greens = new byte[256];
        //private byte[] blues = new byte[256];
        private int[] reds = new int[256];
        private int[] greens = new int[256];
        private int[] blues = new int[256];
        private int[] rFire = {0,0,1,25,49,73,98,122,146,162,173,184,195,207,217,229,240,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255};
        private int[] gFire = {0,0,0,0,0,0,0,0,0,0,0,0,0,14,35,57,79,101,117,133,147,161,175,190,205,219,234,248,255,255,255,255};
        private int[] bFire = {0,61,96,130,165,192,220,227,210,181,151,122,93,64,35,5,0,0,0,0,0,0,0,0,0,0,0,35,98,160,223,255};
        private byte[] rByte;
        private byte[] gByte;
        private byte[] bByte;
        
        public HeatMap() {
            setBackground(Color.WHITE);
            
            // Build the lookup table
            for (int i=0; i<rFire.length; i++) {
                reds[i] = rFire[i];//(byte)rFire[i];
                greens[i] = gFire[i];//(byte)gFire[i];
                blues[i] = bFire[i];//(byte)bFire[i];
                rByte = new byte[rFire.length];
                rByte[i] = (byte)rFire[i];
                gByte = new byte[gFire.length];
                gByte[i] = (byte)gFire[i];
                bByte = new byte[bFire.length];
                bByte[i] = (byte)bFire[i];
            }
            interpolateLUT();
        }
        
        private void interpolateLUT() {//byte[] reds, byte[] greens, byte[] blues, int nColors) {
            int nColors = rFire.length;
            int[] r = new int[nColors]; //byte[] r = new byte[nColors]; 
            int[] g = new int[nColors]; //byte[] g = new byte[nColors]; 
            int[] b = new int[nColors];//byte[] b = new byte[nColors];
            System.arraycopy(reds, 0, r, 0, nColors);
            System.arraycopy(greens, 0, g, 0, nColors);
            System.arraycopy(blues, 0, b, 0, nColors);
            double scale = nColors/256.0;
            int i1, i2;
            double fraction;
            for (int i=0; i<256; i++) {
                i1 = (int)(i*scale);
                i2 = i1+1;
                if (i2==nColors) i2 = nColors-1;
                fraction = i*scale - i1;
                //IJ.write(i+" "+i1+" "+i2+" "+fraction);
                reds[i] = (int)((1.0-fraction)*(r[i1]&255) + fraction*(r[i2]&255));//(byte)((1.0-fraction)*(r[i1]&255) + fraction*(r[i2]&255));
                greens[i] = (int)((1.0-fraction)*(g[i1]&255) + fraction*(g[i2]&255));//(byte)((1.0-fraction)*(g[i1]&255) + fraction*(g[i2]&255));
                blues[i] = (int)((1.0-fraction)*(b[i1]&255) + fraction*(b[i2]&255));//(byte)((1.0-fraction)*(b[i1]&255) + fraction*(b[i2]&255));
            }
        }
        
        @Override
        protected void paintComponent(Graphics gr) {
            super.paintComponent(gr);
            Graphics2D g = (Graphics2D) gr;
            if (map == null) {
                return;
            }
            availableWidth = getWidth() - (2 * margin);
            heightPerLeaf = (getHeight() - (2 * margin)) / map.length;
            widthPerGene = availableWidth / (map[0].length + 2);//(getWidth()  - (2 * margin)) / map[0].length;//geneCount; // Have a problem here!!!!! Something to do with getWidth()????
            currentY = 0;
            // Find highest value
            float max = 0.0f;
            for (int leaf = 0; leaf < map.length; leaf++) {
                for (int gene = 0; gene < map[0].length; gene++) {
                    if (map[leaf][gene] > max) {
                        max = map[leaf][gene];
                    }
                }
            }
            // Draw heatmap
            for (int leaf = 0; leaf < map.length; leaf++) {
                for (int gene = 0; gene < map[0].length; gene++) {
                    float heat = 0.75f * map[leaf][gene] / max;
                    int lutIndex = (int) (255.0f * heat);
                    if (lutIndex > 255) {
                        lutIndex = 255;
                    }
                    //Color c = new Color(heat, heat, heat);
                    Color c = new Color(reds[lutIndex], greens[lutIndex], blues[lutIndex]);
                    g.setColor(c);//red[lutIndex], green[lutIndex], blue[lutIndex] ) );
                    g.fillRect(margin+(gene*widthPerGene), margin+(leaf*heightPerLeaf), widthPerGene, heightPerLeaf);
                }
            }
            //Draw colorbar
            g.setColor(Color.BLACK);
            int barWidth = (int)(0.5F*widthPerGene);
            int barHeight = getHeight() - (3*margin);
            int barX = margin+(int)((map[0].length+0.5f)*widthPerGene);
            int barY = (int)(1.5f * margin);
            g.fillRect( barX, barY, barWidth, barHeight);
                // Draw scale
                g.setColor(Color.BLACK);
                g.drawLine(barX + barWidth, barY, barX + (int)(1.5f * barWidth), barY);
                g.drawLine(barX + barWidth, barY + (int)(0.25f * barHeight), barX + (int)(1.25f * barWidth), barY + (int)(0.25f * barHeight));
                g.drawLine(barX + barWidth, barY + (int)(0.5f * barHeight), barX + (int)(1.5f * barWidth), barY + (int)(0.5f * barHeight));
                g.drawLine(barX + barWidth, barY + (int)(0.75f * barHeight), barX + (int)(1.25f * barWidth), barY + (int)(0.75f * barHeight));
                g.drawLine(barX + barWidth, barY + barHeight - 1, barX + (int)(1.5f * barWidth), barY + barHeight - 1);
                // Label scale result = String.format("%.2f", value);
                g.drawString( String.format("%.2f", (max * (4.0f/3.0f) ) ), barX + (int)(1.5f * barWidth), barY);
                g.drawString( String.format("%.2f", (max * (3.0f/3.0f) ) ), barX + (int)(1.5f * barWidth), barY + (int)(0.25f * barHeight) );
                g.drawString( String.format("%.2f", (max * (2.0f/3.0f) ) ), barX + (int)(1.5f * barWidth), barY + (int)(0.5f * barHeight) );
                g.drawString( String.format("%.2f", (max * (1.0f/3.0f) ) ), barX + (int)(1.5f * barWidth), barY + (int)(0.75f * barHeight));
                g.drawString( String.format("%.2f", 0.0f),                  barX + (int)(1.5f * barWidth), barY + barHeight - 1);
            barHeight = barHeight - 2;
            barWidth = barWidth - 2;
            barX = barX + 1;
            barY = barY;// + 1;
            for (int y = 0; y < barHeight; y++) {
                float barHeat = (float) y / (float) barHeight;
                int lutIndex = (int) (255.0f * barHeat);
                if (lutIndex > 255) {
                    lutIndex = 255;
                }
                Color c = new Color(reds[lutIndex], greens[lutIndex], blues[lutIndex]);
                g.setColor(c);
                g.fillRect( barX, barY + (barHeight - y), barWidth, 1 );
            }
        }
        
        private void draw(Graphics g, ClusterNode node) {
            // Check if there is a left branch to draw:
            boolean leftToDraw = false;
            IJ.log("draw() was called!");
            if (node.getLeftIndex() != -1) {
                if ( (clusterTree.getNodeAtIndex( node.getLeftIndex() ).getNodeIsDrawn() ) ||
                     (clusterTree.getNodeAtIndex( node.getLeftIndex() ).getVisibleChildCount() > 0) ) {
                    leftToDraw = true;
                }
            }
            // Check if there is a right branch to draw:
            boolean rightToDraw = false;
            if (node.getRightIndex() != -1) {
                if ( (clusterTree.getNodeAtIndex( node.getRightIndex() ).getNodeIsDrawn() ) ||
                     (clusterTree.getNodeAtIndex( node.getRightIndex() ).getVisibleChildCount() > 0) ) {
                    rightToDraw = true;
                }
            }
            if ( ! (leftToDraw || rightToDraw)) {
                // If neither branch is drawn...
                // ...this is a leaf
                IJ.log("Getting data for " + node.toString() );
                g.setColor(node.color);
                g.fillRect(margin+(0*widthPerGene), margin+(currentY*heightPerLeaf), widthPerGene, heightPerLeaf);
                currentY++;
            } else {
                // ...otherwise pass on to next node to be drawn
                if (leftToDraw) {
                    draw(g, clusterTree.getNodeAtIndex( node.getLeftIndex() ) );
                } else if (rightToDraw) {
                    draw(g, clusterTree.getNodeAtIndex( node.getRightIndex() ) );
                }
            }
        }
    }
    
    private class WrapLayout extends FlowLayout {
	private Dimension preferredLayoutSize;

	/**
	* Constructs a new <code>WrapLayout</code> with a left
	* alignment and a default 5-unit horizontal and vertical gap.
	*/
	public WrapLayout()
	{
		super();
	}

	/**
	* Constructs a new <code>FlowLayout</code> with the specified
	* alignment and a default 5-unit horizontal and vertical gap.
	* The value of the alignment argument must be one of
	* <code>WrapLayout</code>, <code>WrapLayout</code>,
	* or <code>WrapLayout</code>.
	* @param align the alignment value
	*/
	public WrapLayout(int align)
	{
		super(align);
	}

	/**
	* Creates a new flow layout manager with the indicated alignment
	* and the indicated horizontal and vertical gaps.
	* <p>
	* The value of the alignment argument must be one of
	* <code>WrapLayout</code>, <code>WrapLayout</code>,
	* or <code>WrapLayout</code>.
	* @param align the alignment value
	* @param hgap the horizontal gap between components
	* @param vgap the vertical gap between components
	*/
	public WrapLayout(int align, int hgap, int vgap)
	{
		super(align, hgap, vgap);
	}

	/**
	* Returns the preferred dimensions for this layout given the
	* <i>visible</i> components in the specified target container.
	* @param target the component which needs to be laid out
	* @return the preferred dimensions to lay out the
	* subcomponents of the specified container
	*/
	@Override
	public Dimension preferredLayoutSize(Container target)
	{
		return layoutSize(target, true);
	}

	/**
	* Returns the minimum dimensions needed to layout the <i>visible</i>
	* components contained in the specified target container.
	* @param target the component which needs to be laid out
	* @return the minimum dimensions to lay out the
	* subcomponents of the specified container
	*/
	@Override
	public Dimension minimumLayoutSize(Container target)
	{
		Dimension minimum = layoutSize(target, false);
		minimum.width -= (getHgap() + 1);
		return minimum;
	}

	/**
	* Returns the minimum or preferred dimension needed to layout the target
	* container.
	*
	* @param target target to get layout size for
	* @param preferred should preferred size be calculated
	* @return the dimension to layout the target container
	*/
	private Dimension layoutSize(Container target, boolean preferred)
	{
	synchronized (target.getTreeLock())
	{
		//  Each row must fit with the width allocated to the containter.
		//  When the container width = 0, the preferred width of the container
		//  has not yet been calculated so lets ask for the maximum.

		int targetWidth = target.getSize().width;

		if (targetWidth == 0)
			targetWidth = Integer.MAX_VALUE;

		int hgap = getHgap();
		int vgap = getVgap();
		Insets insets = target.getInsets();
		int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);
		int maxWidth = targetWidth - horizontalInsetsAndGap;

		//  Fit components into the allowed width

		Dimension dim = new Dimension(0, 0);
		int rowWidth = 0;
		int rowHeight = 0;

		int nmembers = target.getComponentCount();

		for (int i = 0; i < nmembers; i++)
		{
			Component m = target.getComponent(i);

			if (m.isVisible())
			{
				Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();

				//  Can't add the component to current row. Start a new row.

				if (rowWidth + d.width > maxWidth)
				{
					addRow(dim, rowWidth, rowHeight);
					rowWidth = 0;
					rowHeight = 0;
				}

				//  Add a horizontal gap for all components after the first

				if (rowWidth != 0)
				{
					rowWidth += hgap;
				}

				rowWidth += d.width;
				rowHeight = Math.max(rowHeight, d.height);
			}
		}

		addRow(dim, rowWidth, rowHeight);

		dim.width += horizontalInsetsAndGap;
		dim.height += insets.top + insets.bottom + vgap * 2;

		//	When using a scroll pane or the DecoratedLookAndFeel we need to
		//  make sure the preferred size is less than the size of the
		//  target containter so shrinking the container size works
		//  correctly. Removing the horizontal gap is an easy way to do this.

		Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);

		if (scrollPane != null && target.isValid())
		{
			dim.width -= (hgap + 1);
		}

		return dim;
	}
	}

	/*
	 *  A new row has been completed. Use the dimensions of this row
	 *  to update the preferred size for the container.
	 *
	 *  @param dim update the width and height when appropriate
	 *  @param rowWidth the width of the row to add
	 *  @param rowHeight the height of the row to add
	 */
	private void addRow(Dimension dim, int rowWidth, int rowHeight)
	{
		dim.width = Math.max(dim.width, rowWidth);

		if (dim.height > 0)
		{
			dim.height += getVgap();
		}

		dim.height += rowHeight;
	}
    }
}